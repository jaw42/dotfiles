#!/bin/bash

# ---------------------------------------------------------
# Variables.
# Change things here to suit your needs.
# ---------------------------------------------------------

# Genres -----------
Genre_array=(text video audio pdf web image word spreadsheet)

# Programs ---------
#   text_fast=gvim
#text_complex=subl
#
#       video=mplayer
#       audio=mplayer
#
#    pdf_fast=zathura
# pdf_complex=evince
#
#    web_fast=luakit
# web_complex=google-chrome
#
#       image=fehviewer
#
#        word=abiword
#
# spreadsheet=gnumeric

#     Genre=("fast"     "complex"       )
       text=(gvim       subl            )
      video=(mplayer                    )
      audio=(mplayer                    )
        pdf=(zathura    evince          )
        web=(luakit     google-chrome   )
      image=(fehviewer  mirage          )
       word=(abiword                    )
spreadsheet=(gnumeric                   )

# File types -------
       text_array=(txt )
      video_array=(mpg mpeg avi webm)
      audio_array=(mp3 ogg vorbis m4a m4b)
        pdf_array=(pdf)
        web_array=(html htm)
      image_array=(jpg jpeg png bmp gif tiff svg)
       word_array=(docx doc odf rtf)
spreadsheet_array=(gnumeric xls xlsx)

# Other Options ----
default=fast # fast/complex
verbose_output=false # true/false

# --------------------------------------------------------
# Program
# --------------------------------------------------------

# Check if a value exists in an array
# Usage: in_array "$needle" "${haystack[@]}"
# See: http://fvue.nl/wiki/Bash:_Check_if_array_element_exists
in_array() {
    local hay needle=$1
    shift
    for hay; do
        [[ $hay == $needle ]] && return 0
    done
    return 1
}

verbose() {
    if $verbose_output; then
        if [[ $2 == "n" ]]; then
           echo -n $1 
        else 
            echo $1
        fi
    fi
}

dumpFunc() {
    if $dumpOutput; then
        dump="2> /dev/null"
    fi
}

# --------------------------------------------------------
# Usage details
# --------------------------------------------------------
helpOutput() {
    cat << 'EOF'

Usage:
  open [options] <file|url>

Options:
  -f     use the "fast" program
  -c     use the "complex" program
  -v     output debugging info
  -d     dump output error messages so they are not displayed
                ****Does not yet work****
  -h     print this help message
EOF
}

if [[ $# -eq 0 ]]; then
    helpOutput
    exit
fi

# --------------------------------------------------------------
# Options Handler
# --------------------------------------------------------------
while getopts ":fcvhd" opt; do
    case $opt in
        f)
            verbose "Fast option selected"
            fast=true
            complex=false
            ;;
        c)
            verbose "Complex option selected"
            complex=true
            fast=false
            ;;
        v)
            verbose "Verbose option selected"
            verbose_output=true
            ;;
        h)
            helpOutput
            ;;
        d) 
            dumpOutput=true
            dumpFunc
            verbose "Dumping output to null"
            ;;
        \?)
            echo "Unkown option: -$OPTARG. Defaulting to fast"
    esac
done

shift $((OPTIND-1))

# --------------------------------------------------------------
# URL Handler
# --------------------------------------------------------------
#regex='(https?|ftp|file)://[-A-Za-z0-9\+&@#/%?=~_|!:,.;]*[-A-Za-z0-9\+&@#/%=~_|]'
regex='((([A-Za-z]{3,9}:(?:\/\/)?)(?:[-;:&=\+\$,\w]+@)?[A-Za-z0-9.-]+|(?:www.|[-;:&=\+\$,\w]+@)[A-Za-z0-9.-]+)((?:\/[\+~%\/.\w-_]*)?\??(?:[-\+=&;%@.\w_]*)#?(?:[.\!\/\\w]*))?)'

if  echo "$1" | grep -q -P $regex ; then
    if $fast; then
        verbose "Found url, using web browser - $web_fast"
        $web_fast "$1"
    else
        verbose "Found url, using web browser - $web_complex"
        $web_complex "$1"
    fi
    exit
fi

# --------------------------------------------------------------
# File parser and handler
#   This is admittedly fantastically difficult to understand,
#+  used for flexibility. New genres with new filetypes can be
#+  added by the user easily without changing anything here.
#
# Genre_array[0] = fast
# Genre_array[1] = complex
# --------------------------------------------------------------
ext=${1##*.}
ext=${ext,,}
verbose "Extension is $ext"
for fileType in "${Genre_array[@]}" ; do
    fileType_array="$fileType""_array[@]"
    
    verbose "Checking genre $fileType ..." 

    if in_array $ext "${!fileType_array}"; then
        verbose "Found extension $ext in genre $fileType"

        do_fast=$fileType[0]
        do_complex=$fileType[1]

        verbose "Filetype = $fileType"
        if $fast; then
            verbose "Executing ${!do_fast}"
            eval ${!do_fast} "\"$1\"" $dump
        elif $complex; then
            verbose "Executing ${!do_complex}"
            eval ${!do_complex} "\"$1\"" $dump
        else
            verbose "No fast/complex option given, using default - $default"
            if [[ $default=="fast" ]]; then
                verbose "Executing ${!do_fast}"
                eval ${!do_fast} "\"$1\"" $dump
            else
                verbose "Executing ${!do_complex}"
                eval ${!do_complex} "\"$1\"" $dump
            fi
        fi
        exit 0
    else
        verbose "nope"
    fi
done
echo "Filetype not recognised"

# ------------------------------------------------------------
# If no extension is given, or the extension is not recognised
#+  then use the mimetype of the file.
# ------------------------------------------------------------
mimeType=$(file --mime-type -b "$1")

# Delete from string everything after "/"
mimeType=${mimeType%/*}
echo "Mime-type is $mimeType"

do_fast=$mimeType[0]
do_complex=$mimeType[1]

if $fast; then
    verbose "Executing ${!do_fast}"
    eval ${!do_fast} "\"$1\"" $dump
elif $complex; then
    verbose "Executing ${!do_complex}"
    eval ${!do_complex} "\"$1\"" $dump
fi
